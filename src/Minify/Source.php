<?php

namespace Support\Minify;

use Core\Exception\FilesystemException;
use Stringable;
use Support\Curl;
use Support\Minify\Source\Type;
use function Support\{class_id, normalize_path, path_info, str_bisect, str_squish};

/**
 * Generated by a {@see \Support\Minify} class.
 *
 * @internal
 * @author Martin Nielsen
 */
final class Source implements Stringable
{
    private readonly Curl $curl;

    /** @var array<string, Source> */
    private array $imports = [];

    public array $importStatements = [];

    protected ?bool $exists = null;

    protected null|false|int $lastModified = null;

    protected string $source;

    public readonly Type $type;

    public function __construct( string|Stringable $source )
    {
        $source       = (string) $source;
        $this->type   = Type::from( $source );
        $this->source = Type::normalize( $source, $this->type );
    }

    public function __toString() : string
    {
        return $this->source;
    }

    public function is( Type $type ) : bool
    {
        return $this->type === $type;
    }

    /**
     * @return array<string, Source>
     */
    public function getImports() : array
    {
        // Only import local sources
        if ( $this->type !== Type::PATH || ! $this->exists() ) {
            return [];
        }

        if ( $this->imports ) {
            return $this->imports;
        }

        [$directory, , $extension] = path_info( $this->source );

        foreach (
            $this->extractImportStatements() as $path
        ) {
            $ext = \pathinfo( $path, PATHINFO_EXTENSION ) || null;

            if ( ! \file_exists( $path ) ) {
                $path = normalize_path(
                    path      : "{$directory}/{$path}",
                    traversal : true,
                );
            }

            foreach ( $ext ? [$path] : \glob( "{$path}/*.{$extension}" ) as $import ) {
                $hash = \hash( algo : 'xxh64', data : $import );

                if ( \array_key_exists( $hash, $this->imports ) ) {
                    continue;
                }

                $source = new Source( $import );
                if ( $source->exists() !== true ) {
                    continue;
                }

                $this->imports[$hash] = $source;

                if ( $source->is( Type::PATH ) ) {
                    $this->imports = [...$this->imports, ...$source->getImports()];
                }
            }
        }

        return $this->imports;
    }

    public function lastModified() : int|false
    {
        if ( ! $this->exists() ) {
            return false;
        }

        if ( $this->lastModified !== null ) {
            return $this->lastModified;
        }

        $lastModified = match ( $this->type ) {
            Type::STRING => \hexdec( \hash( 'crc32c', $this->source ) ),
            Type::PATH   => \filemtime( $this->source ),
            Type::URL    => $this->curl->getInfo( CURLINFO_FILETIME ),
            default      => false,
        };

        if ( ! ( \is_int( $lastModified ) || $lastModified === false ) ) {
            $lastModified = false;
        }

        return $this->lastModified = $lastModified;
    }

    public function exists(
        bool $revalidate = false,
    ) : bool {
        if ( $revalidate ) {
            $this->exists = null;
        }
        return $this->exists ??= match ( $this->type ) {
            Type::STRING => empty( $this->source ) === false,
            Type::PATH   => \file_exists( $this->source ),
            Type::URL    => $this->exists = $this->curl()
                ->setOptions(
                    CURLOPT_NOBODY         : true,
                    CURLOPT_TIMEOUT        : 5,
                    CURLOPT_FAILONERROR    : true,
                    CURLOPT_RETURNTRANSFER : true,
                )
                ->curl()->httpExists,
            default => false,
        };
    }

    public function get() : string
    {
        return $this->source;
    }

    public function curl() : Curl
    {
        return $this->curl ??= new Curl(
            $this->type === Type::URL ? $this->source : null,
            [
                CURLOPT_FOLLOWLOCATION => true,
                CURLOPT_FILETIME       => true,
            ],
        );
    }

    public function __destruct()
    {
        if ( isset( $this->curl ) ) {
            $this->curl->close();
        }
    }

    public static function hash( string|Stringable $value ) : string
    {
        return $value instanceof Stringable
                ? class_id( $value, true )
                : \hash( algo : 'xxh64', data : $value );
    }

    /**
     * @return non-empty-string[]
     */
    private function extractImportStatements() : array
    {
        $stream = \fopen( $this->source, 'r' );

        if ( ! $stream ) {
            throw new FilesystemException( "Unable to open file { {$this->source} }" );
        }

        $parse        = [];
        $blockComment = false;

        while ( false !== ( $line = \fgets( $stream ) ) ) {
            // Remove any whitespace, continue if empty
            if ( ! $line = str_squish( $line ) ) {
                continue;
            }

            // Continue inside block comments
            if ( \str_contains( $line, '/*' ) ) {
                $blockComment = true;
            }
            if ( $blockComment && \str_contains( $line, '*/' ) ) {
                $blockComment = false;
            }
            // Continue on any comment
            elseif ( $blockComment || \str_starts_with( $line, '//' ) ) {
                continue;
            }
            // Store imports and continue
            elseif ( \str_contains( $line, 'import' ) ) {
                while ( $semicolon = \strpos( $line, ';' ) ) {
                    $parse[] = str_bisect( $line, $semicolon + 1 );
                }

                $parse[] = $line;
            }
            // All imports must be start of a file, we can safely break early
            else {
                break;
            }
        }
        \fclose( $stream );

        $import = [];

        foreach ( $parse as $statement ) {
            // Skip empty values
            if ( ! $statement = \trim( $statement ) ) {
                continue;
            }
            $this->importStatements[] = $statement;

            // Remove the `import` statement
            $value = \substr( $statement, \strpos( $statement, 'import' ) + 6 );

            // Trim import value, quotes, semicolons and whitespace
            $import[] = \trim( $value, " '\"\n\r\t\v\0;" );
        }

        return $import;
    }
}
